# Лабораторна Робота 7

### 1\. Розробка `docker-compose.yml`

Ваш поточний файл `docker-compose.yml` (який ви завантажили раніше) вже повністю відповідає вимогам, оскільки він описує всі три необхідні сервіси, їхні залежності та налаштування мережі.

Ось фінальний **`docker-compose.yml`**:

```yaml
version: '3.8'

services:
  # 1. СЕРВІС ЧЕРГИ ТА КЕШУ
  redis:
    image: redis:6-alpine
    container_name: redis_queue_cache
    networks:
      - internal_network
    command: redis-server --appendonly yes 

  # 2. СЕРВІС СТІЙКОГО СХОВИЩА (POSTGRESQL)
  postgres:
    image: postgres:15-alpine
    container_name: postgres_db
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: jobs_db
    volumes:
      - postgres_data:/var/lib/postgresql/data # Стійкий Volume для БД
    networks:
      - internal_network

  # 3. СЕРВІС API-ШЛЮЗУ 
  api:
    build:
      context: .
      dockerfile: Dockerfile.api
    container_name: image_api_gateway
    ports:
      - "8080:8080"
    volumes:
      - ./storage:/app/storage
    depends_on:
      - redis
      - postgres 
    networks:
      - internal_network
    environment:
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=
      # ЗМІННІ СЕРЕДОВИЩА ДЛЯ POSTGRES
      - PG_HOST=postgres
      - PG_PORT=5432
      - PG_USER=user
      - PG_PASSWORD=password
      - PG_DBNAME=jobs_db

  # 4. СЕРВІС ОБРОБКИ 
  worker:
    build:
      context: .
      dockerfile: Dockerfile.worker
    container_name: image_worker_service
    volumes:
      - ./storage:/app/storage
    depends_on:
      - redis
      - postgres 
    networks:
      - internal_network
    environment:
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=
      # ЗМІННІ СЕРЕДОВИЩА ДЛЯ POSTGRES
      - PG_HOST=postgres
      - PG_PORT=5432
      - PG_USER=user
      - PG_PASSWORD=password
      - PG_DBNAME=jobs_db

networks:
  internal_network:
    driver: bridge

volumes:
  postgres_data: # Визначення Volume для Postgre
```

### 2\. Налаштування Мережевих Зв'язків (Service Discovery)

Цей крок виконано через секції `networks` та `environment`:

1.  **Створення спільної мережі:** Усі три сервіси (`redis`, `api`, `worker`) додані до однієї спільної мережі: `internal_network`.

    ```yaml
    networks:
      internal_network:
    # ...
    services:
      # ...
      redis:
        networks:
          - internal_network
      # ...
    ```

2.  **Service Discovery:** Docker Compose автоматично надає **DNS-ім'я**, яке відповідає назві сервісу. Це дозволяє `api` та `worker` звертатися до Redis, використовуючи його ім'я:

      * **API Gateway** та **Worker Service** використовують змінну оточення `REDIS_HOST: redis`.
      * Docker Compose під час запуску автоматично налаштовує мережу так, що запит до хоста `redis` з контейнерів `api` чи `worker` потрапляє саме до контейнера Redis.

### 3\. Перевірка Роботи Системи

Для перевірки роботи всієї системи, оркестрованої Docker Compose, виконайте ці кроки:

#### 3.1. Запуск Усіх Сервісів

Виконайте одну команду для збирання образів (якщо вони ще не зібрані) та запуску всіх контейнерів у фоновому режимі:

```bash
docker compose up --build -d
```

#### 3.2. Перевірка Статусу

Всі три контейнери (redis, api, worker) запущені та працюють:

```bash
docker compose ps
```

Очікуваний вивід (статус **`Up`** для всіх):

```
NAME                    IMAGE                   STATUS
image_api_gateway       .../api-gateway:latest  Up      
image_worker_service    .../worker-service:latest Up    
redis_queue_cache       redis:6-alpine          Up 
```

#### 3.3. Тестування REST API (Взаємодія мікросервісів)


1.  **Надіслати Завдання (POST):**
    Надішліть тестове зображення (наприклад, `test_input.jpg`) та команду обробки (`grayscale`):

    ```bash
    curl -X POST http://localhost:8080/api/v1/jobs/submit \
      -H 'Content-Type: multipart/form-data' \
      -F 'image=@./storage/test_input.jpg' \
      -F 'action=grayscale'
    ```

    **Очікувана відповідь (API Gateway):**

    ```json
    {"job_id": "a1b2c3d4-...", "status": "QUEUED"}
    ```

2.  **Перевірка Обробки (Worker Service Log):**

    ```bash
    docker logs image_worker_service
    ```

    **Очікувані логи:**

    ```
    worker/main.go:...: Received New Event: Job Submitted. Data: a1b2c3d4-...|./storage/...|grayscale|
    worker/main.go:...: Status updated to PROCESSING for job a1b2c3d4-...
    worker/main.go:...: Job a1b2c3d4-... COMPLETED. Result saved to: ./storage/processed_...
    ```

3.  **Перевірка Статусу Завдання (GET):**

    ```bash
    curl http://localhost:8080/api/v1/jobs/status/a1b2c3d4-...
    ```

    **Очікувана відповідь (API Gateway):**

    ```json
    {"job_id": "a1b2c3d4-...", "status": "COMPLETED", "output_path": "./storage/processed_..."}
    ```
