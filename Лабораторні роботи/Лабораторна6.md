# Лабораторна Робота 6

### 1\. Реалізовано Асинхронну Взаємодію (Завдання 1 & 2)

Міжсервісна взаємодія реалізована за патерном **Producer-Consumer** з використанням черги **Redis List** (`image_processing_queue`).

| Сервіс | Роль | Механізм | Дія (Подія) |
| :--- | :--- | :--- | :--- |
| **API-Gateway** | Відправник | `RDB.RPush()` | Публікує подію `Job Submitted` (деталі завдання) у чергу. |
| **Worker-Service** | Споживач | `RDB.BLPop()` | Блокуюче очікує та споживає подію `Job Submitted` для обробки. |

#### 1.1. Код Відправника (API Gateway)

Сервіс API-Gateway приймає HTTP-запит, зберігає метадані в PostgreSQL і **публікує подію** в чергу Redis.

```go
// api/main.go, submitJobHandler

// ... (CREATE: Вставка в PostgreSQL та збереження файлу) ...

// 4. PUSH: Публікація Події (Event Publishing) у Redis
jobData := fmt.Sprintf("%s|%s|%s|%s", jobID, filePath, action, params)
queueName := "image_processing_queue"

// Подія (повідомлення) додається у кінець черги
err = a.RDB.RPush(ctx, queueName, jobData).Err() 
if err != nil {
    log.Printf("Error pushing job event to Redis queue: %v", err)
    // Обробка помилки...
    return
}

// ... (Відповідь клієнту status: QUEUED) ...
```

#### 1.2. Код Споживача (Worker Service)

Сервіс Worker-Service постійно працює у фоновому режимі, реалізуючи цикл споживання, що відповідає за **обробку подій**.

```go
// worker/main.go, processQueue

func processQueue(rdb *redis.Client, pgDB *pgx.Conn) {
    log.Println("Worker started listening for events...")
    queueName := "image_processing_queue"
    ctx := context.Background()

    for {
        // BLPOP: Блокуючий виклик, який очікує на надходження події.
        // Забезпечує слабке зв'язування: Worker чекає, не навантажуючи CPU.
        result, err := rdb.BLPop(ctx, 0, queueName).Result()
        
        if err != nil {
            // Обробка помилок підключення
            log.Printf("Error receiving event from Redis: %v", err)
            time.Sleep(5 * time.Second) 
            continue
        }

        // result[1] - це фактичне повідомлення (подія)
        jobData := result[1]
        log.Printf("Received New Event: Job Submitted. Data: %s", jobData)
        
        // --- Обробка події ---
        jobID, inputPath, action, params, _ := parseJobData(jobData)
        
        // 1. Worker оновлює статус у PG: PROCESSING (Компенсаційні дії не потрібні, оскільки статус оновлюється)
        updatePGStatus(pgDB, jobID, "PROCESSING", "")
        
        // 2. Виконання роботи... processImage()
        
        // 3. Worker оновлює статус у PG: COMPLETED/FAILED
        // ...
    }
}
```

### 2\. Демонстрація Обробки Події (Завдання 3)

Процес обробки події перевіряється двома етапами:

#### 2.1. Відправка Події через Postman

Клієнт відправляє запит на обробку зображення. API Gateway підтверджує, що подію було поставлено в чергу (асинхронно).

  * **POST** `http://<ваш-ip>:8080/job/submit`
  * **Очікувана відповідь (API Gateway):**
    ```json
    {"job_id": "...", "status": "QUEUED"}
    ```
Це підтверджує, що **подія успішно опублікована** в чергу Redis.

#### 2.2. Перевірка Обробки у Логах Worker-Service

Одразу після отримання відповіді від API Gateway, Worker-Service споживає цю подію та починає обробку.

  * **Команда перевірки логів:** `docker logs image_worker_service` (або аналог у Kubernetes)
  * **Логи (Worker-Service):**
    ```
    worker/main.go:66: Received New Event: Job Submitted. Data: 8a3e742e-...|./storage/...|grayscale|
    worker/main.go:88: Status updated to PROCESSING for job 8a3e742e...
    worker/main.go:104: Job 8a3e742e... COMPLETED. Result saved to: ./storage/processed_...
    ```

Ці логи безпосередньо демонструють, що мікросервіс **Worker-Service** успішно **спожив та обробив подію**, надіслану мікросервісом **API-Gateway**, що повністю підтверджує реалізацію асинхронної міжсервісної взаємодії.

### 3\. Конфігурація Середовища (Docker Compose)

Ключовим для забезпечення міжсервісної взаємодії є налаштування мережі та Service Discovery у `docker-compose.yml`, що дозволяє `api` та `worker` знаходити сервіс `redis` за його іменем.

```yaml
# docker-compose.yml (Фрагмент, що забезпечує зв'язок)

services:
  # 1. БРОКЕР ПОВІДОМЛЕНЬ (REDIS)
  redis:
    image: redis:6-alpine
    container_name: redis_queue_cache
    networks:
      - internal_network # Всі сервіси у спільній мережі

  # 2. API-GATEWAY (Відправник)
  api:
    # ...
    depends_on:
      - redis
    environment:
      - REDIS_HOST=redis # Ім'я сервісу Redis, доступне в мережі
      # ...

  # 3. WORKER-SERVICE (Споживач)
  worker:
    # ...
    depends_on:
      - redis
    environment:
      - REDIS_HOST=redis # Ім'я сервісу Redis, доступне в мережі
      # ...
```
