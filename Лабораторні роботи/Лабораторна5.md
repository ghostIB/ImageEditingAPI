# Лабораторна Робота № 5

## Завдання

В рамках цієї лабораторної роботи було успішно реалізовано прототип мікросервісу **API-Gateway** з підтримкою базових **CRUD-операцій** для сутності **Job** (Завдання) та інтеграцією **PostgreSQL** як основного стійкого сховища.

### 1\. Реалізовано CRUD-операції для сутності «Job»

Було визначено та імплементовано сутність **Job** для відстеження стану обробки зображень.

  * **Структура даних Job:** Для стійкого зберігання в PostgreSQL була розроблена таблиця `jobs`, що містить ключові поля для забезпечення надійності: `id` (UUID), `status` (поточний стан), `input_path` та `output_path` (шляхи до файлів у Shared Volume).

  * **REST-інтерфейс (API-Gateway):** Реалізовано синхронну взаємодію з клієнтом через REST API та асинхронну взаємодію з БД.

| Операція | Метод/Шлях | Дія |
| :--- | :--- | :--- |
| **CREATE** | `POST /upload` | Створює запис у PostgreSQL (`status=PENDING`), зберігає файл та пушить `job_id` у Redis. |
| **READ** | `GET /jobs/{id}` | Зчитує поточний статус завдання та шляхи до файлів із PostgreSQL. |
| **UPDATE** | Внутрішня | **Worker-Service** оновлює статус у PostgreSQL (`PROCESSING` $\rightarrow$ `COMPLETED`). |

**Фрагмент коду (API-Gateway, Go) для операції CREATE:**

```go
// Створення нового запису в PostgreSQL
func (a *API) CreateJob(jobID uuid.UUID, inputPath string) error {
    query := `INSERT INTO jobs (id, status, input_path) VALUES ($1, $2, $3)`
    // Використання підключення до БД (a.PGDB)
    _, err := a.PGDB.Exec(context.Background(), query, jobID, "PENDING", inputPath)
    if err != nil {
        log.Printf("Помилка INSERT до PostgreSQL: %v", err)
        return err
    }
    return nil
}

// Успішно інтегровано виклик CreateJob у PostUploadHandler.
```

-----

### 2\. Зберігання даних у базі (PostgreSQL)

Була проведена інтеграція **PostgreSQL** як стійкого сховища, яке замінило використання Redis для довгострокового зберігання метаданих.

**Оновлений файл `docker-compose.yml` (Конфігурація PostgreSQL):**

Був доданий новий сервіс `postgres`, існуючі сервіси `api` та `worker` були оновлені для коректного підключення.

```yaml
# ... інші сервіси ...

  # 4. СЕРВІС СТІЙКОГО СХОВИЩА (POSTGRESQL)
  postgres:
    image: postgres:15-alpine
    container_name: postgres_db
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: jobs_db
    volumes:
      - postgres_data:/var/lib/postgresql/data # Стійкий Volume
    networks:
      - internal_network

  # ... оновлення сервісу api та worker ...
  api:
    # ...
    depends_on:
      - redis
      - postgres # Додано залежність
    environment:
      # ... змінні Redis ...
      - PG_HOST=postgres
      - PG_PORT=5432
      - PG_USER=user
      - PG_PASSWORD=password
      - PG_DBNAME=jobs_db
    networks:
      - internal_network

# ... визначення volumes ...
volumes:
  postgres_data:
```

### 3\. Налаштовано контейнеризацію за допомогою Dockerfile

Файли **`Dockerfile.api`** та **`Dockerfile.worker`** були успішно оновлені для включення необхідних залежностей PostgreSQL та забезпечення робочого середовища.

  * **Оновлення залежностей Go:** До файлів `go.mod` обох сервісів був доданий драйвер для PostgreSQL (наприклад, `github.com/jackc/pgx/v5`).
  * **Багатостадійна збірка:** Була збережена багатостадійна збірка на основі `golang:1.25-alpine`, що забезпечило мінімальний розмір фінальних образів.
  * **Спільне Сховище:** Каталог `/app/storage` продовжує створюватися та отримувати права доступу (`chmod -R 777`) у фінальному образі, що критично для спільного використання файлового сховища (Shared Docker Volume).

**Результат:** Сервіси **API-Gateway** та **Worker-Service** скомпільовані з підтримкою БД, можуть підключатися до контейнера PostgreSQL та коректно виконувати CRUD-операції для управління життєвим циклом завдання.
